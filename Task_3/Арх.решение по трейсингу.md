## Архитектурное решение по трейсингу

### 1. Мотивация
    Напишите здесь, почему в систему нужно добавить трейсинг и что это даст компании. 
    Опишите возможные три-пять технические и бизнес-метрики решения, на которые повлияет внедрение трейсинга

- трейсинг позволит определить место проблем при переходах заказов между статусами, которые судя по схеме связаны с цепочками HTTP запросов, очередями и SQL запросов между несколькими микросервисами.

Влияние на технические и бизнес-решения:
- какие части системы требуют приоритетного масштабирования;
- какие части системы требуют приоритетного изменения архитектуры (например, разделения на микросервисы, смены технологий или внедрения новых асинхронных процессы);
- каких именно инженеров не хватает в первую очередь;

#### 2. Анализ и поиск проблемных мест, где может помочь трейсинг
    Проанализируйте систему компании и C4-диаграмму в контексте планирования трейсинга. 
    Напишите и выделите на схеме системы, которые следует покрыть трейсингом. 
    Для этого идентифицируйте места, где заказ может «сломаться» или зависнуть
- короткая цепочка создания заказа: загрузка 3d файла - создание заказа в CRM - подтверждение для пользователя; 
- длинная цепочка создания заказа: загрузка файла - CRM - очередь - расчет цены в MES - очередь - формирование цены;
- внешний вызов MES_API: запрос цены/загрузка файла MES API - очередь - создание заказа в CRM;
- подтверждение заказа по рассчитанной цене - CRM - очередь - MES API - взятие заказа в производство в MES;
- цепочка изменений любых статусов MES - MES API - очередь - CRM - SHOP API;

### 3. Предлагаемое решение
    Опишите, как и с помощью каких технологий будет реализован трейсинг, какие компоненты нужно внедрить или доработать. 
    Отразите компоненты и новые связи на схеме. Скачайте диаграмму контейнеров «Александрита» в модели C4. 
    Доработайте диаграмму, исходя из вашего решения: отразите на ней новые компоненты и связи. 
    Новые элементы выделяйте красным цветом.

#### Архитектура компонентов
1. OpenTelemetry (OTel) sdk для встраивания в код бэкенд приложений, чтобы собирать трассировки вокруг http запросов, а также SQL запросов, отправляемых в Postgres хранилища;
2. Для трассировки сообщений в Messages Queue пишущие и читающие из очереди микросервисы (MES_API, CRM_API) будут заполнять соответствующие заголовки в сообщениях; 
3. Новый компонент OTel Collector Agent для сбора трассировок с микросервисов (MES_API, CRM_API, SHOP_API) - в виде сайдкаров в контейнерах приложений;
4. Новый компонент OpenTelemetry Collector — Gateway (кластер)
   - сбор трассировок из агентов, ретраи, батчинг, семплинг (выборочное сохранение трассировок), маршрутизация в очередь для записи в хранилище.
5. Запись в основное хранилище метрик через новый топик в Messages Queue для сглаживания и повышения надежности.
6. Jaeger Ingester + Jaeger Query + Jaeger UI
    - чтение из очереди и запись в хранилище, чтение из хранилища, визуализация;
7. Хранилище трассировок ClickHouse (позволяет обеспечить большой поток на запись, подходит для организации поиска трассировок, одновременно подходит для хранения метрик).

#### Настройки и нюансы
1. Скорей всего пригодится сэмплинг:
   - Head-based sampling на входе (в SDK/Agent);
     - Часто: 0.1–1% для очень больших RPS; 5–20% для внутренних/критических сервисов с небольшим трафиком.
   - Tail-based sampling в Gateway (лучше качества):
     - Всегда сохраняем ошибочные (status!=OK).
     - Сохраняем медленные (p95/p99>порога).
     - Подмешиваем случайные 0.1–1% «нормальных» для репрезентативности.
2. Разделение долгих асинхронных операций на более мелкие спаны, например:
   - расчет цены по 3d модели: загрузка модели, упрощение модели, общая оценка времени и сложности производства, финальная оценка цены;
3. Хранение трассировок.
   - Hot (оперативный, быстрый поиск): 2–7 дней.
   - Warm (подешевле, чуть медленнее): 14–30 дней.
   - Cold/Archive (если нужно): 60–180 дней (обычно только для инцидентов/аудита и с сильным семплингом); 
   - В сlickHouse — TTL с партициями/индексами.

### 4. Компромиссы
    Опишите, в каких случаях трейсинг не принесёт пользы или пока невозможен, 
    или его реализация обойдётся слишком дорого

- При большом потоке запросов, ретраев без сэмлинга будет сильно расти место для хранилища, с сэмплингом можем что-то пропустить;
- Без автоматического анализа трассировок с настроенными алертами (новый сервис из п.5), возможно, будет трудно оперативно выявлять проблемы;
  - пример: тайминги увеличились, появились зависания заказов, но выборочный просмотр трассировки может быть бесполезен, если происходит частичная деградация; 
- Возможны сложности с настройкой спанов для долгих асинхроннных процессов:
  - если время расчета цены будет сильно отличаться, то трудно будет сходу определить, что процесс создания заказа упал, либо идет расчет цены?
  - если случается вспышка упавших процессов, то ожидание завершения их спанов в OTel Collector приведет к большому росту потребления оперативной памяти;
- При этом более короткие трассировки (http запрос на расчет цены - положили в очередь) могут не давать полной картины:
  - отдельно каждый этап по трассировкам работает ок;
  - но причина проблем не видна в трассировках;

### 5. Дополнительное задание
    Спроектируйте и опишите, как будет реализованы автоматический мониторинг процесса прохождения заказа, полученные из данных трейсинга, и алертинг. 
    Обновите последний вариант диаграммы, который вы подготовили для этого раздела, — отразите на нём необходимые связи. 
    Новые элементы выделяйте зелёным цветом.
1. Можно завести новый микросервис `Order Journey Analyzer`, который бы мог отвечать за:
- быть потребителем traces.events из RabbitMQ.
- Дедуплицировать трассировки, искать корреляцию трассировок с order_id, user_id, cart_id, production_id.
- писать, в ClickHouse или Postgres (SHOP_DB) историю заказов `order_journey` со статусами, таймингами, ошибками, ретраями и т.п.;
- искать аномалии в `order_journey` (нарушения этапов, увеличения таймингов, зависания) и генерировать алерты для отправки в AlertsManager;
2. AlertsManager принимает алерты от `order_analyzer` через вебхуки, снижает шум и сигнализирует во все необходимые каналы (tg, телефон).
3. В Grafana отбражаем алерты из AlertsManager на новых дашбордах.


### 6. Схема контейнеров
![jewerly_c4_model_task3.svg](jewerly_c4_model_task3.svg)